import { GraphQLError as e, Kind as t, parse as r, print as n } from "graphql";

import { make as o } from "wonka";

const rehydrateGraphQlError = t => {
  if ("string" == typeof t) {
    return new e(t);
  } else if ("object" == typeof t && t.message) {
    return new e(t.message, t.nodes, t.source, t.positions, t.path, t, t.extensions || {});
  } else {
    return t;
  }
};

class CombinedError extends Error {
  constructor(e) {
    const t = (e.graphQLErrors || []).map(rehydrateGraphQlError);
    const r = ((e, t) => {
      let r = "";
      if (e) {
        return `[Network] ${e.message}`;
      }
      if (t) {
        for (const e of t) {
          if (r) {
            r += "\n";
          }
          r += `[GraphQL] ${e.message}`;
        }
      }
      return r;
    })(e.networkError, t);
    super(r);
    this.name = "CombinedError";
    this.message = r;
    this.graphQLErrors = t;
    this.networkError = e.networkError;
    this.response = e.response;
  }
  toString() {
    return this.message;
  }
}

const phash = (e, t) => {
  for (let r = 0, n = 0 | t.length; r < n; r++) {
    e = (e << 5) + e + t.charCodeAt(r);
  }
  return 0 | e;
};

const hash = e => phash(5381, e) >>> 0;

const s = new Set;

const i = new WeakMap;

const stringify = e => {
  if (null === e || s.has(e)) {
    return "null";
  } else if ("object" != typeof e) {
    return JSON.stringify(e) || "";
  } else if (e.toJSON) {
    return stringify(e.toJSON());
  } else if (Array.isArray(e)) {
    let t = "[";
    for (let r of e) {
      if ("[" !== t) {
        t += ",";
      }
      r = stringify(r);
      t += r.length > 0 ? r : "null";
    }
    t += "]";
    return t;
  }
  const t = Object.keys(e).sort();
  if (!t.length && e.constructor && e.constructor !== Object) {
    const t = i.get(e) || Math.random().toString(36).slice(2);
    i.set(e, t);
    return `{"__key":"${t}"}`;
  }
  s.add(e);
  let r = "{";
  for (const n of t) {
    const t = stringify(e[n]);
    if (t) {
      if (r.length > 1) {
        r += ",";
      }
      r += stringify(n) + ":" + t;
    }
  }
  s.delete(e);
  r += "}";
  return r;
};

const stringifyVariables = e => {
  s.clear();
  return stringify(e);
};

const a = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;

const c = /([\s,]|#[^\n\r]+)+/g;

const replaceOutsideStrings = (e, t) => t % 2 == 0 ? e.replace(c, " ").trim() : e;

const stringifyDocument = e => {
  let t = ("string" != typeof e ? e.loc && e.loc.source.body || n(e) : e).split(a).map(replaceOutsideStrings).join("");
  if ("string" != typeof e) {
    const r = "definitions" in e && getOperationName(e);
    if (r) {
      t = `# ${r}\n${t}`;
    }
    if (!e.loc) {
      e.loc = {
        start: 0,
        end: t.length,
        source: {
          body: t,
          name: "gql",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      };
    }
  }
  return t;
};

const l = new Map;

const keyDocument = e => {
  let t;
  let n;
  if ("string" == typeof e) {
    t = hash(stringifyDocument(e));
    n = l.get(t) || r(e, {
      noLocation: !0
    });
  } else {
    t = e.__key || hash(stringifyDocument(e));
    n = l.get(t) || e;
  }
  if (!n.loc) {
    stringifyDocument(n);
  }
  n.__key = t;
  l.set(t, n);
  return n;
};

const createRequest = (e, t) => {
  if (!t) {
    t = {};
  }
  const r = keyDocument(e);
  return {
    key: phash(r.__key, stringifyVariables(t)) >>> 0,
    query: r,
    variables: t
  };
};

const getOperationName = e => {
  for (const r of e.definitions) {
    if (r.kind === t.OPERATION_DEFINITION && r.name) {
      return r.name.value;
    }
  }
};

const getOperationType = e => {
  for (const r of e.definitions) {
    if (r.kind === t.OPERATION_DEFINITION) {
      return r.operation;
    }
  }
};

const makeResult = (e, t, r) => {
  if (!("data" in t) && !("errors" in t) || "path" in t) {
    throw new Error("No Content");
  }
  return {
    operation: e,
    data: t.data,
    error: Array.isArray(t.errors) ? new CombinedError({
      graphQLErrors: t.errors,
      response: r
    }) : void 0,
    extensions: "object" == typeof t.extensions && t.extensions || void 0,
    hasNext: !!t.hasNext
  };
};

const mergeResultPatch = (e, t, r) => {
  const n = {
    ...e
  };
  n.hasNext = !!t.hasNext;
  if (!("path" in t)) {
    if ("data" in t) {
      n.data = t.data;
    }
    return n;
  }
  if (Array.isArray(t.errors)) {
    n.error = new CombinedError({
      graphQLErrors: n.error ? [ ...n.error.graphQLErrors, ...t.errors ] : t.errors,
      response: r
    });
  }
  let o = n.data = {
    ...n.data
  };
  let s = 0;
  let i;
  while (s < t.path.length) {
    i = t.path[s++];
    o = o[i] = Array.isArray(o[i]) ? [ ...o[i] ] : {
      ...o[i]
    };
  }
  Object.assign(o, t.data);
  return n;
};

const makeErrorResult = (e, t, r) => ({
  operation: e,
  data: void 0,
  error: new CombinedError({
    networkError: t,
    response: r
  }),
  extensions: void 0
});

function makeFetchBody(e) {
  return {
    query: n(e.query),
    operationName: getOperationName(e.query),
    variables: e.variables || void 0,
    extensions: void 0
  };
}

const makeFetchURL = (e, t) => {
  if (!("query" === e.kind && !!e.context.preferGetMethod) || !t) {
    return e.context.url;
  }
  const r = new URL(e.context.url);
  const n = r.searchParams;
  if (t.operationName) {
    n.set("operationName", t.operationName);
  }
  if (t.query) {
    n.set("query", t.query.replace(/#[^\n\r]+/g, " ").trim());
  }
  if (t.variables) {
    n.set("variables", stringifyVariables(t.variables));
  }
  if (t.extensions) {
    n.set("extensions", stringifyVariables(t.extensions));
  }
  const o = r.toString();
  if (o.length > 2047) {
    e.context.preferGetMethod = !1;
    return e.context.url;
  }
  return o;
};

const makeFetchOptions = (e, t) => {
  const r = "query" === e.kind && !!e.context.preferGetMethod;
  const n = {
    accept: "application/graphql+json, application/json"
  };
  if (!r) {
    n["content-type"] = "application/json";
  }
  const o = ("function" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions) || {};
  if (o.headers) {
    for (const e in o.headers) {
      n[e.toLowerCase()] = o.headers[e];
    }
  }
  return {
    ...o,
    body: !r && t ? JSON.stringify(t) : void 0,
    method: r ? "GET" : "POST",
    headers: n
  };
};

const f = "undefined" != typeof TextDecoder ? new TextDecoder : null;

const u = /content-type:[^\r\n]*application\/json/i;

const d = /boundary="?([^=";]+)"?/i;

const makeFetchSource = (e, t, r) => {
  const n = "manual" === r.redirect ? 400 : 300;
  const s = e.context.fetch;
  return o((({next: o, complete: i}) => {
    const a = "undefined" != typeof AbortController ? new AbortController : null;
    if (a) {
      r.signal = a.signal;
    }
    let c = !1;
    const executeIncrementalFetch = (e, t, r) => {
      const n = r.headers && r.headers.get("Content-Type") || "";
      if (/text\//i.test(n)) {
        return r.text().then((n => {
          e(makeErrorResult(t, new Error(n), r));
        }));
      } else if (!/multipart\/mixed/i.test(n)) {
        return r.text().then((n => {
          e(makeResult(t, JSON.parse(n), r));
        }));
      }
      let o = "---";
      const s = n.match(d);
      if (s) {
        o = "--" + s[1];
      }
      let i;
      let cancel = () => {};
      if (r[Symbol.asyncIterator]) {
        const e = r[Symbol.asyncIterator]();
        i = e.next.bind(e);
      } else if ("body" in r && r.body) {
        const e = r.body.getReader();
        cancel = () => e.cancel();
        i = () => e.read();
      } else {
        throw new TypeError("Streaming requests unsupported");
      }
      let a = "";
      let l = !0;
      let p = null;
      let h = null;
      return i().then((function next(n) {
        if (!n.done) {
          const i = "Buffer" === (s = n.value).constructor.name ? s.toString() : f.decode(s);
          let c = i.indexOf(o);
          if (c > -1) {
            c += a.length;
          } else {
            c = a.indexOf(o);
          }
          a += i;
          while (c > -1) {
            const n = a.slice(0, c);
            const s = a.slice(c + o.length);
            if (l) {
              l = !1;
            } else {
              const o = n.indexOf("\r\n\r\n") + 4;
              const i = n.slice(0, o);
              const a = n.slice(o, n.lastIndexOf("\r\n"));
              let c;
              if (u.test(i)) {
                try {
                  c = JSON.parse(a);
                  p = h = h ? mergeResultPatch(h, c, r) : makeResult(t, c, r);
                } catch (e) {}
              }
              if ("--" === s.slice(0, 2) || c && !c.hasNext) {
                if (!h) {
                  return e(makeResult(t, {}, r));
                }
                break;
              }
            }
            a = s;
            c = a.indexOf(o);
          }
        } else {
          c = !0;
        }
        var s;
        if (p) {
          e(p);
          p = null;
        }
        if (!n.done && (!h || h.hasNext)) {
          return i().then(next);
        }
      })).finally(cancel);
    };
    let l = !1;
    let p = !1;
    let h;
    Promise.resolve().then((() => {
      if (l) {
        return;
      }
      return (s || fetch)(t, r);
    })).then((t => {
      if (!t) {
        return;
      }
      h = t;
      p = h.status < 200 || h.status >= n;
      return executeIncrementalFetch(o, e, h);
    })).then(i).catch((t => {
      if (c) {
        throw t;
      }
      const r = makeErrorResult(e, p ? h.statusText ? new Error(h.statusText) : t : t, h);
      o(r);
      i();
    }));
    return () => {
      l = !0;
      if (a) {
        a.abort();
      }
    };
  }));
};

export { CombinedError as C, makeErrorResult as a, makeFetchBody as b, makeFetchURL as c, makeFetchOptions as d, makeFetchSource as e, createRequest as f, getOperationType as g, stringifyVariables as h, mergeResultPatch as i, getOperationName as j, keyDocument as k, makeResult as m, stringifyDocument as s };
//# sourceMappingURL=3606e9b5.mjs.map
