import { visit as e, Kind as t, print as n } from "graphql";

import { k as o, s as r, C as s, m as c, a as u, b as p, c as l, d, e as y, g as k, f as g } from "./3606e9b5.mjs";

export { C as CombinedError, f as createRequest, j as getOperationName, a as makeErrorResult, m as makeResult, i as mergeResultPatch, h as stringifyVariables } from "./3606e9b5.mjs";

import { subscribe as x, share as b, map as w, filter as E, tap as O, merge as N, mergeMap as q, takeUntil as v, make as _, onPush as D, makeSubject as S, onEnd as P, onStart as R, publish as V, take as A, switchMap as M, fromValue as T } from "wonka";

const collectTypes = (e, t) => {
  if (Array.isArray(e)) {
    for (const n of e) {
      collectTypes(n, t);
    }
  } else if ("object" == typeof e && null !== e) {
    for (const n in e) {
      if ("__typename" === n && "string" == typeof e[n]) {
        t.add(e[n]);
      } else {
        collectTypes(e[n], t);
      }
    }
  }
  return t;
};

const formatNode = e => {
  if (!e.selectionSet) {
    return e;
  }
  for (const n of e.selectionSet.selections) {
    if (n.kind === t.FIELD && "__typename" === n.name.value && !n.alias) {
      return e;
    }
  }
  return {
    ...e,
    selectionSet: {
      ...e.selectionSet,
      selections: [ ...e.selectionSet.selections, {
        kind: t.FIELD,
        name: {
          kind: t.NAME,
          value: "__typename"
        }
      } ]
    }
  };
};

const I = new Map;

const formatDocument = t => {
  const n = o(t);
  let r = I.get(n.__key);
  if (!r) {
    r = e(n, {
      Field: formatNode,
      InlineFragment: formatNode
    });
    Object.defineProperty(r, "__key", {
      value: n.__key,
      enumerable: !1
    });
    I.set(n.__key, r);
  }
  return r;
};

const maskTypename = e => {
  if (!e || "object" != typeof e) {
    return e;
  } else if (Array.isArray(e)) {
    return e.map(maskTypename);
  } else if (e && "object" == typeof e && "__typename" in e) {
    const t = {};
    for (const n in e) {
      if ("__typename" === n) {
        Object.defineProperty(t, "__typename", {
          enumerable: !1,
          value: e.__typename
        });
      } else {
        t[n] = maskTypename(e[n]);
      }
    }
    return t;
  } else {
    return e;
  }
};

function withPromise(e) {
  e.toPromise = () => new Promise((t => {
    const n = x((e => {
      if (!e.stale && !e.hasNext) {
        Promise.resolve().then((() => {
          n.unsubscribe();
          t(e);
        }));
      }
    }))(e);
  }));
  return e;
}

function makeOperation(e, t, n) {
  if (!n) {
    n = t.context;
  }
  return {
    key: t.key,
    query: t.query,
    variables: t.variables,
    kind: e,
    context: n
  };
}

const addMetadata = (e, t) => makeOperation(e.kind, e, {
  ...e.context,
  meta: {
    ...e.context.meta,
    ...t
  }
});

const noop = () => {};

const applyDefinitions = (e, n, o) => {
  for (const s of o) {
    if (s.kind === t.FRAGMENT_DEFINITION) {
      const t = s.name.value;
      const o = r(s);
      if (!e.has(t)) {
        e.set(t, o);
        n.push(s);
      } else if ("production" !== process.env.NODE_ENV && e.get(t) !== o) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + t + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      n.push(s);
    }
  }
};

function gql() {
  const e = new Map;
  const n = [];
  const r = [];
  let s = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (let e = 1; e < arguments.length; e++) {
    const t = arguments[e];
    if (t && t.definitions) {
      r.push(...t.definitions);
    } else {
      s += t;
    }
    s += arguments[0][e];
  }
  applyDefinitions(e, n, o(s).definitions);
  applyDefinitions(e, n, r);
  return o({
    kind: t.DOCUMENT,
    definitions: n
  });
}

const shouldSkip = ({kind: e}) => "mutation" !== e && "query" !== e;

const cacheExchange = ({forward: e, client: t, dispatchDebug: n}) => {
  const o = new Map;
  const r = new Map;
  const mapTypeNames = e => {
    const t = makeOperation(e.kind, e);
    t.query = formatDocument(e.query);
    return t;
  };
  const isOperationCached = e => {
    const {key: t, kind: n, context: {requestPolicy: r}} = e;
    return "query" === n && "network-only" !== r && ("cache-only" === r || o.has(t));
  };
  return s => {
    const i = b(s);
    const a = w((e => {
      const r = o.get(e.key);
      "production" !== process.env.NODE_ENV && n({
        operation: e,
        ...r ? {
          type: "cacheHit",
          message: "The result was successfully retried from the cache"
        } : {
          type: "cacheMiss",
          message: "The result could not be retrieved from the cache"
        },
        source: "cacheExchange"
      });
      const s = {
        ...r,
        operation: addMetadata(e, {
          cacheOutcome: r ? "hit" : "miss"
        })
      };
      if ("cache-and-network" === e.context.requestPolicy) {
        s.stale = !0;
        reexecuteOperation(t, e);
      }
      return s;
    }))(E((e => !shouldSkip(e) && isOperationCached(e)))(i));
    const c = O((e => {
      let {operation: s} = e;
      if (!s) {
        return;
      }
      const i = (e => [ ...collectTypes(e, new Set) ])(e.data).concat(s.context.additionalTypenames || []);
      if ("mutation" === e.operation.kind) {
        const a = new Set;
        "production" !== process.env.NODE_ENV && n({
          type: "cacheInvalidation",
          message: `The following typenames have been invalidated: ${i}`,
          operation: s,
          data: {
            typenames: i,
            response: e
          },
          source: "cacheExchange"
        });
        for (let e = 0; e < i.length; e++) {
          const t = i[e];
          let n = r.get(t);
          if (!n) {
            r.set(t, n = new Set);
          }
          for (const e of n.values()) {
            a.add(e);
          }
          n.clear();
        }
        for (const e of a.values()) {
          if (o.has(e)) {
            s = o.get(e).operation;
            o.delete(e);
            reexecuteOperation(t, s);
          }
        }
      } else if ("query" === s.kind && e.data) {
        o.set(s.key, e);
        for (let e = 0; e < i.length; e++) {
          const t = i[e];
          let n = r.get(t);
          if (!n) {
            r.set(t, n = new Set);
          }
          n.add(s.key);
        }
      }
    }))(e(E((e => "query" !== e.kind || "cache-only" !== e.context.requestPolicy))(w((e => addMetadata(e, {
      cacheOutcome: "miss"
    })))(N([ w(mapTypeNames)(E((e => !shouldSkip(e) && !isOperationCached(e)))(i)), E((e => shouldSkip(e)))(i) ])))));
    return N([ a, c ]);
  };
};

const reexecuteOperation = (e, t) => e.reexecuteOperation(makeOperation(t.kind, t, {
  ...t.context,
  requestPolicy: "network-only"
}));

const F = new Set;

const ssrExchange = (e = {}) => {
  const t = !!e.staleWhileRevalidate;
  const n = !!e.includeExtensions;
  const o = {};
  const r = [];
  const invalidate = e => {
    r.push(e.operation.key);
    if (1 === r.length) {
      Promise.resolve().then((() => {
        let e;
        while (e = r.shift()) {
          o[e] = null;
        }
      }));
    }
  };
  const ssr = ({client: r, forward: i}) => a => {
    const c = e && "boolean" == typeof e.isClient ? !!e.isClient : !r.suspense;
    const u = b(a);
    let p = i(E((e => !o[e.key] || !!o[e.key].hasNext))(u));
    let l = w((e => {
      const i = ((e, t, n) => ({
        operation: e,
        data: t.data ? JSON.parse(t.data) : void 0,
        extensions: n && t.extensions ? JSON.parse(t.extensions) : void 0,
        error: t.error ? new s({
          networkError: t.error.networkError ? new Error(t.error.networkError) : void 0,
          graphQLErrors: t.error.graphQLErrors
        }) : void 0,
        hasNext: t.hasNext
      }))(e, o[e.key], n);
      if (t && !F.has(e.key)) {
        i.stale = !0;
        F.add(e.key);
        reexecuteOperation(r, e);
      }
      return i;
    }))(E((e => !!o[e.key] && "network-only" !== e.context.requestPolicy))(u));
    if (!c) {
      p = O((e => {
        const {operation: t} = e;
        if ("mutation" !== t.kind) {
          const r = (({hasNext: e, data: t, extensions: n, error: o}, r) => {
            const s = {};
            if (void 0 !== t) {
              s.data = JSON.stringify(t);
            }
            if (r && void 0 !== n) {
              s.extensions = JSON.stringify(n);
            }
            if (e) {
              s.hasNext = !0;
            }
            if (o) {
              s.error = {
                graphQLErrors: o.graphQLErrors.map((e => {
                  if (!e.path && !e.extensions) {
                    return e.message;
                  }
                  return {
                    message: e.message,
                    path: e.path,
                    extensions: e.extensions
                  };
                }))
              };
              if (o.networkError) {
                s.error.networkError = "" + o.networkError;
              }
            }
            return s;
          })(e, n);
          o[t.key] = r;
        }
      }))(p);
    } else {
      l = O(invalidate)(l);
    }
    return N([ p, l ]);
  };
  ssr.restoreData = e => {
    for (const t in e) {
      if (null !== o[t]) {
        o[t] = e[t];
      }
    }
  };
  ssr.extractData = () => {
    const e = {};
    for (const t in o) {
      if (null != o[t]) {
        e[t] = o[t];
      }
    }
    return e;
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
};

const subscriptionExchange = ({forwardSubscription: e, enableAllOperations: t, isSubscriptionOperation: o}) => ({client: r, forward: s}) => {
  const i = o || (e => {
    const {kind: n} = e;
    return "subscription" === n || !!t && ("query" === n || "mutation" === n);
  });
  return t => {
    const o = b(t);
    const a = q((t => {
      const {key: s} = t;
      const i = E((e => "teardown" === e.kind && e.key === s))(o);
      return v(i)((t => {
        const o = e({
          key: t.key.toString(36),
          query: n(t.query),
          variables: t.variables,
          context: {
            ...t.context
          }
        });
        return _((({next: e, complete: n}) => {
          let s = !1;
          let i;
          Promise.resolve().then((() => {
            if (s) {
              return;
            }
            i = o.subscribe({
              next: n => e(c(t, n)),
              error: n => e(u(t, n)),
              complete: () => {
                if (!s) {
                  s = !0;
                  if ("subscription" === t.kind) {
                    r.reexecuteOperation(makeOperation("teardown", t, t.context));
                  }
                  n();
                }
              }
            });
          }));
          return () => {
            s = !0;
            if (i) {
              i.unsubscribe();
            }
          };
        }));
      })(t));
    }))(E(i)(o));
    const p = s(E((e => !i(e)))(o));
    return N([ a, p ]);
  };
};

const debugExchange = ({forward: e}) => {
  if ("production" === process.env.NODE_ENV) {
    return t => e(t);
  } else {
    return t => O((e => console.log("[Exchange debug]: Completed operation: ", e)))(e(O((e => console.log("[Exchange debug]: Incoming operation: ", e)))(t)));
  }
};

const dedupExchange = ({forward: e, dispatchDebug: t}) => {
  const n = new Set;
  const filterIncomingOperation = e => {
    const {key: o, kind: r} = e;
    if ("teardown" === r || "mutation" === r) {
      n.delete(o);
      return !0;
    }
    const s = n.has(o);
    n.add(o);
    if (s) {
      "production" !== process.env.NODE_ENV && t({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e,
        source: "dedupExchange"
      });
    }
    return !s;
  };
  const afterOperationResult = ({operation: e, hasNext: t}) => {
    if (!t) {
      n.delete(e.key);
    }
  };
  return t => {
    const n = E(filterIncomingOperation)(t);
    return O(afterOperationResult)(e(n));
  };
};

const fetchExchange = ({forward: e, dispatchDebug: t}) => n => {
  const o = b(n);
  const r = q((e => {
    const {key: n} = e;
    const r = p(e);
    const s = l(e, r);
    const i = d(e, r);
    "production" !== process.env.NODE_ENV && t({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e,
      data: {
        url: s,
        fetchOptions: i
      },
      source: "fetchExchange"
    });
    const a = v(E((e => "teardown" === e.kind && e.key === n))(o))(y(e, s, i));
    if ("production" !== process.env.NODE_ENV) {
      return D((n => {
        const o = !n.data ? n.error : void 0;
        "production" !== process.env.NODE_ENV && t({
          type: o ? "fetchError" : "fetchSuccess",
          message: `A ${o ? "failed" : "successful"} fetch response has been returned.`,
          operation: e,
          data: {
            url: s,
            fetchOptions: i,
            value: o || n
          },
          source: "fetchExchange"
        });
      }))(a);
    }
    return a;
  }))(E((e => "query" === e.kind || "mutation" === e.kind))(o));
  const s = e(E((e => "query" !== e.kind && "mutation" !== e.kind))(o));
  return N([ r, s ]);
};

const fallbackExchange = ({dispatchDebug: e}) => t => E((() => !1))(O((t => {
  if ("teardown" !== t.kind && "production" !== process.env.NODE_ENV) {
    const n = `No exchange has handled operations of kind "${t.kind}". Check whether you've added an exchange responsible for these operations.`;
    "production" !== process.env.NODE_ENV && e({
      type: "fallbackCatch",
      message: n,
      operation: t,
      source: "fallbackExchange"
    });
    console.warn(n);
  }
}))(t));

const Q = fallbackExchange({
  dispatchDebug: noop
});

const composeExchanges = e => ({client: t, forward: n, dispatchDebug: o}) => e.reduceRight(((e, n) => n({
  client: t,
  forward: e,
  dispatchDebug(e) {
    "production" !== process.env.NODE_ENV && o({
      timestamp: Date.now(),
      source: n.name,
      ...e,
      source: "fetchExchange"
    });
  }
})), n);

const errorExchange = ({onError: e}) => ({forward: t}) => n => O((({error: t, operation: n}) => {
  if (t) {
    e(t, n);
  }
}))(t(n));

const L = [ dedupExchange, cacheExchange, fetchExchange ];

const $ = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  const t = new Map;
  const n = new Map;
  const o = [];
  const r = {
    url: e.url,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    preferGetMethod: !!e.preferGetMethod,
    requestPolicy: e.requestPolicy || "cache-first"
  };
  const {source: s, next: i} = S();
  let a = !1;
  function dispatchOperation(e) {
    if (e) {
      i(e);
    }
    if (!a) {
      a = !0;
      while (a && (e = o.shift())) {
        i(e);
      }
      a = !1;
    }
  }
  const makeResultSource = r => {
    let a = E((e => e.operation.kind === r.kind && e.operation.key === r.key && (!e.operation.context._instance || e.operation.context._instance === r.context._instance)))(d);
    if (e.maskTypename) {
      a = w((e => ({
        ...e,
        data: maskTypename(e.data)
      })))(a);
    }
    if ("mutation" === r.kind) {
      return A(1)(R((() => i(r)))(a));
    }
    return b(P((() => {
      t.delete(r.key);
      n.delete(r.key);
      for (let e = o.length - 1; e >= 0; e--) {
        if (o[e].key === r.key) {
          o.splice(e, 1);
        }
      }
      i(makeOperation("teardown", r, r.context));
    }))(D((e => {
      t.set(r.key, e);
    }))(M((e => {
      if ("query" !== r.kind || e.stale) {
        return T(e);
      }
      return N([ T(e), w((() => ({
        ...e,
        stale: !0
      })))(A(1)(E((e => "query" === e.kind && e.key === r.key && "cache-only" !== e.context.requestPolicy))(s))) ]);
    }))(v(E((e => "teardown" === e.kind && e.key === r.key))(s))(a)))));
  };
  const c = this instanceof Client ? this : Object.create(Client.prototype);
  const u = Object.assign(c, {
    suspense: !!e.suspense,
    operations$: s,
    reexecuteOperation(e) {
      if ("mutation" === e.kind || n.has(e.key)) {
        o.push(e);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createRequestOperation(e, t, n) {
      if (!n) {
        n = {};
      }
      const o = k(t.query);
      if ("production" !== process.env.NODE_ENV && "teardown" !== e && o !== e) {
        throw new Error(`Expected operation of type "${e}" but found "${o}"`);
      }
      return makeOperation(e, t, {
        _instance: "mutation" === e ? [] : void 0,
        ...r,
        ...n,
        suspense: n.suspense || !1 !== n.suspense && u.suspense
      });
    },
    executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return makeResultSource(e);
      }
      return _((o => {
        let r = n.get(e.key);
        if (!r) {
          n.set(e.key, r = makeResultSource(e));
        }
        const s = "cache-and-network" === e.context.requestPolicy || "network-only" === e.context.requestPolicy;
        return x(o.next)(P((() => {
          a = !1;
          o.complete();
        }))(R((() => {
          const n = t.get(e.key);
          if ("subscription" === e.kind) {
            return dispatchOperation(e);
          } else if (s) {
            dispatchOperation(e);
          }
          if (null != n && n === t.get(e.key)) {
            o.next(s ? {
              ...n,
              stale: !0
            } : n);
          } else if (!s) {
            dispatchOperation(e);
          }
        }))(r))).unsubscribe;
      }));
    },
    executeQuery(e, t) {
      const n = u.createRequestOperation("query", e, t);
      return u.executeRequestOperation(n);
    },
    executeSubscription(e, t) {
      const n = u.createRequestOperation("subscription", e, t);
      return u.executeRequestOperation(n);
    },
    executeMutation(e, t) {
      const n = u.createRequestOperation("mutation", e, t);
      return u.executeRequestOperation(n);
    },
    query(e, t, n) {
      if (!n || "boolean" != typeof n.suspense) {
        n = {
          ...n,
          suspense: !1
        };
      }
      return withPromise(u.executeQuery(g(e, t), n));
    },
    readQuery(e, t, n) {
      let o = null;
      x((e => {
        o = e;
      }))(u.query(e, t, n)).unsubscribe();
      return o;
    },
    subscription: (e, t, n) => u.executeSubscription(g(e, t), n),
    mutation: (e, t, n) => withPromise(u.executeMutation(g(e, t), n))
  });
  let p = noop;
  if ("production" !== process.env.NODE_ENV) {
    const {next: e, source: t} = S();
    u.subscribeToDebugTarget = e => x(e)(t);
    p = e;
  }
  const l = composeExchanges(void 0 !== e.exchanges ? e.exchanges : L);
  const d = b(l({
    client: u,
    dispatchDebug: p,
    forward: fallbackExchange({
      dispatchDebug: p
    })
  })(s));
  V(d);
  return u;
};

const G = $;

export { $ as Client, cacheExchange, composeExchanges, G as createClient, debugExchange, dedupExchange, L as defaultExchanges, errorExchange, Q as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, maskTypename, ssrExchange, subscriptionExchange };
//# sourceMappingURL=urql-core.mjs.map
